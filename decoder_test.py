from matplotlib.mlab import phase_spectrum
import sounddevice as sd
from sympy import cofactors
import visualize
import numpy as np
import scipy.signal
import playsound
from ctypes.util import find_library
import matplotlib.pyplot as plt
import decoder as d
import encoder as e
find_library('portaudio')

seconds = 8
fs = 44100
gain = 1
f0 = 1000
block_length = 10000# 8192
f1 = f0 + block_length
no = 1

sync = playsound.gen_chirp(f0,f1,fs,1)
sync = playsound.double_signal(sync)

input = input('press space')
recording = sd.rec(fs * seconds,samplerate = fs,channels=1)
sd.wait()
recording = recording.flatten()

correlation = scipy.signal.correlate(recording, sync)
peak_correlation = np.max(correlation)
#position = int(np.where(correlation == peak_correlation)[0]) - len(sync) + no
position = np.argmax(correlation) - len(sync) + no
print("position:", position)
print(len(sync))
# plt.plot(correlation)
# plt.show()
#plt.plot(recording)
#plt.show()

def CFO(sync):
    chirp1 = recording[position : position + len(sync)//2]
    chirp2 = recording[position + len(sync)//2 :position + len(sync)]
    fft_chirp1 = np.fft.fft(chirp1)[f0:f1]
    fft_chirp2 = np.fft.fft(chirp2)[f0:f1]

    #Calculate the phase shift between chirp1 and 2
    phase_diff_CFO = np.angle(fft_chirp2 * np.conj(fft_chirp1))
    plt.plot(phase_diff_CFO)
    plt.show

    #phase_diff_CFO = np.angle(fft_chirp2) - np.angle(fft_chirp1)
    #normalized_phase_diff_CFO = np.unwrap(np.angle(fft_chirp2) - np.angle(fft_chirp1))
    #normalized_phase_diff_CFO = (normalized_phase_diff_CFO+ np.pi) % (2 * np.pi) - np.pi
    #plt.plot(normalized_phase_diff_CFO)
    #plt.show
    #normalized_phase_diff_CFO = np.mean(normalized_phase_diff_CFO)
    phase_diff_CFO = np.mean(phase_diff_CFO)
    return phase_diff_CFO

print('CFO phase offset:', CFO(sync))

chirp = recording[position + len(sync)//2 :position+len(sync)]
data = recording[position+len(sync)+fs:position+len(sync)+fs*2]
print('len of chirp:', len(chirp))

fftr = np.fft.fft(chirp)
sync1 = sync[len(sync)//2:]
ffts = np.fft.fft(sync1)

vf0 = f0-300
vf1 = f1+300


additional_margin = 0
channel = fftr / ffts
channel = channel[f0 - additional_margin:f1 + additional_margin]
channel = np.pad(channel,(f0 - additional_margin,fs-f1 - additional_margin))

impulse = np.fft.irfft(channel)

data_fft = np.fft.fft(data)
data_fft = data_fft[f0:f1]

print(len(data_fft))
print("rec", np.angle(data_fft)[:10])
data_fft = data_fft/(channel[f0:f1])
print("adj", np.angle(data_fft)[:10])
print("channel", np.angle(channel[f0:f1])[:10])

bytes_list, r_bits = d.blocks_to_bytes([data_fft],4)


t_bits = e.random_binary(block_length*2)
#t_bits = e.binary[:block_length*2]
#t_bits = "0000000011111111010101011010101001100011001010010110011000000000000011101100111011011111001001110011100001110011111011100110111111100110100011100001111101100010010001001000000001101100010111011101010100110101100010111011110001000100011000110011101101010010111000111101000111011010001110011010010010000101011000010010100011100111110100001011100001100111000010010101011010111001101010011111100011001111100000101000001001001110110000011101001101101101111111000110110101011101101111011010000110100001000011100101011111011100010111110110101000001101000011111010110011000001111101111011111111001110100011001011101100100110110111010101100111011001101010111010010101100000001100111101010000001010101110110011011010010000110010000011111011100110111000010111110101110010010100011010100010011100010011101011111110001001011000011101000101111111011111101100110011100100100011001101001101111011111110011100111010001000111111111101001111011110011111100101000000000110101110101011001000010110111101101010000111100101101001010110011010001111010110010001111100010000010111001111000000011110011000010011011000011001000000011010101011111011111011101000100100001111110010101011010100010111011101101101010001000010011111010100110101110000101110110100110101010011100011001111000000111001110011110011110011101101111111010101101001000111010100000100111110000000000110011100101010110100001101010101000111100101110110010111010100001001011111110001010001111010001101100111010100100111011110101110010011011101110101001110110110000100011111001101111001000100001011100110001001101110100010000101101010010101010000010010100000111010001111111011100111111001001001111001010110001110001101110110111000101001111000011101001001110110100000111110000110110001100100000010001010000011001011010000101100101100000000001111000111100111111000000001110010010101001111100111001111111001001100100001100001000111110110100001000000111010011110000001000111111000011000010001010010011111000111001101010111111001110101101100100011110000101111001001101001011110001001110101010000010010011010111010101000101010110001101001000000000010101000011011111010001000101110100110110001100111110010100100011110011111001010100011000000010110001000111010101011100011111000100100001011011001011111100111010100000000110010111110110100110001010110011100101001010100101011110110100011101110011101110111100001110111110111100001010010011001010101000101011010011101010001110111001111110010101111010010011101011100011001010101111011101010101011010010011010000001111011011110110000110000001111010001100111000011101010001100000110000010011110100011000010100001111000010000001111101000000111010110000110110100111111100010111010110101110010111110111011100111001000011010011010111110000111010101101010000110101110111010010110011110110011100111001010110010000011100010101110010001100001101111011001011110100010000101011101111000001010110000010101101111011011110101101110111100011111011110110100001111111100111010000011010100100100101111101110101110111001001000111001011111010010010100101001010001001001110101000011110010110011100111010110101100101111000110000011011110100110100111100100101000000110001000111001011010001100000110000111101000011100110100101011011001101000111000000000100001011111000001110100000111011000101011011000001100101111010110010010001010001111100100001011111010100101000111011011101100100101101001100100001001111111001010111110110010110111010000000101000010001000010001111000101101101110101010001110110001100101111110100111101010011101101001000001101100110001000010111110101001000001000011101101111100011001100000010011000000010010101010111101100010001101111001001111100100001101010000011011010101111100001111101100111010001110001111001001010100101001100001110010111001011000011100111101101000100110100111100001010110100101100010011110101011111110011000000101010001011111011100101000101011011010010010110110110010000110100001001101011110010110010010101100110011001010000110111110001010100011000111001110101000001101011011000110010110010110111100011000011101011010100100100001110111001010101000001111110111001100010111110010111111011101100110111110111011"
print(r_bits[:99])
print(t_bits[:99])
count = sum(1 for a,b in zip(r_bits,t_bits) if a != b) /(block_length*2) * 100
errors = str(count)[:4] + "%"

print(count, "ERRORS")
#print(phase_offset)
visualize.plot_fft(data_fft,fs,f0,f1,f"phase_offset_TEST-{errors}")
visualize.plot_constellation(data_fft,f"phase_offset_TEST-{errors}")


#CFO_correction = np.exp(-2j * CFO(sync))
#CFO_correction = np.exp(-1j * estimate_phase_offset(recording, sync))
#data_fft = data_fft * CFO_correction

# plt.scatter(range(f0,f1),np.angle(data_fft))
# plt.plot([-np.pi*f/(fs//2) for f in range(f0,f1)],color="red")
# plt.show()

chirp1 = recording[position : position + len(sync)//2]
chirp2 = recording[position + len(sync)//2 :position + len(sync)]
fft_chirp1 = np.fft.fft(chirp1)
fft_chirp2 = np.fft.fft(chirp2)

sfo = 0
for i in range(f0, f1):
    sfo += i * np.angle((fft_chirp2[i]) * np.conj(fft_chirp1[i])) 
sfo = sfo / sum([i**2 for i in range(f0,f1)])

print('SFO:', sfo)

x = np.linspace(f0,f1,f1-f0)
y = np.angle(fft_chirp2[f0:f1] * np.conj(fft_chirp1[f0:f1]))
A = np.vstack([x,np.ones(len(x))]).T
m, c = np.linalg.lstsq(A,y,rcond=None)[0]
print(m,c)

for i in range(len(data_fft)):
    f =  f0 + i
    angle = np.exp(-2j *(f*m+c))
    data_fft[i] = data_fft[i] * angle

CFO_correction = np.exp(-1j * CFO(sync))
#data_fft = data_fft*CFO_correction

bytes_list2, r_bits2 = d.blocks_to_bytes([data_fft],4)

print(r_bits2[:99])
print(t_bits[:99])
count2 = sum(1 for c,d in zip(r_bits2,t_bits) if c != d) /(block_length*2) * 100
errors2 = str(count2)[:4] + "%"

print(count2, "ERRORS")
visualize.plot_fft(data_fft,fs,f0,f1,f"phase_offset_TEST-{errors2}")
visualize.plot_constellation(data_fft,f"phase_offset_TEST-{errors2}")


print(np.angle(channel[f0]))
print(np.angle(CFO_correction))
print(np.angle(data_fft[0]))

plt.scatter(range(f0,f1),np.angle(channel[f0:f1]))
plt.show()